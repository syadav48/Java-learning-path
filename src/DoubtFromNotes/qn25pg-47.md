Qn: 25:
What are the rules for overriding a method in Java?
Rule #7: Use the super keyword to invoke the overridden method from a subclass.

Absolutely âœ… â€” letâ€™s break down **Rule #7: â€œUse the `super` keyword to invoke the overridden method from a subclassâ€** with a clear example and explanation.

---

### ğŸ§  Concept Recap

When a **subclass overrides** a method from its **superclass**, sometimes you still want to call the **original version** (the superclassâ€™s method) inside the subclass.
In such cases, you use the **`super`** keyword.

---

### ğŸ’¡ Example: Overriding and Using `super`

```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
        
        // Calling the superclass version of sound()
        super.sound();
    }
}

public class SuperExample {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
```

---

### ğŸ§© Output:

```
Dog barks
Animal makes a sound
```

---

### ğŸ” Explanation:

* `Dog` overrides the `sound()` method of `Animal`.
* Inside `Dog`â€™s `sound()` method, we still want to execute the original `Animal` version.
* So we use `super.sound()` to call the **overridden method** from the superclass.

---

### ğŸ§± Why use `super` in overridden methods?

1. To **extend** the parent methodâ€™s behavior instead of completely replacing it.
2. To **preserve base logic** (e.g., initialization, logging, etc.) defined in the parent class.
3. Useful in frameworks or when dealing with inheritance hierarchies.

---

### ğŸ§  Bonus Example â€” With Constructor

You can also use `super()` to call the **parent class constructor**:

```java
class Animal {
    Animal() {
        System.out.println("Animal constructor called");
    }
}

class Dog extends Animal {
    Dog() {
        super();  // invokes parent constructor
        System.out.println("Dog constructor called");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
    }
}
```

**Output:**

```
Animal constructor called
Dog constructor called
```

---

Would you like me to show a diagram (like memory and call flow between subclass and superclass when using `super`)?


 # Can a subclass provide its own implementation of a static method from the superclass?
Yes, but that is method hiding, not overriding.

Excellent question ğŸ‘ â€” this is a **common confusion point** in Java OOP:
ğŸ‘‰ â€œCan a subclass provide its own implementation of a `static` method from the superclass?â€

Letâ€™s unpack this **carefully** â€” with an example and visual understanding.

---

### ğŸ§  Key Concept

* **Static methods** belong to the **class itself**, not to any specific object.
* Therefore, **they cannot be overridden**, because overriding works via **dynamic dispatch** (runtime polymorphism based on the object).
* However, a subclass **can define a static method with the same name and signature** â€” this is called **method hiding**, not overriding.

---

### ğŸ’¡ Example â€” Method Hiding

```java
class Parent {
    static void display() {
        System.out.println("Display from Parent");
    }
}

class Child extends Parent {
    static void display() {   // method hiding (not overriding)
        System.out.println("Display from Child");
    }
}

public class StaticMethodExample {
    public static void main(String[] args) {
        Parent p = new Parent();
        Child c = new Child();
        Parent ref = new Child();  // Parent reference, Child object

        p.display();    // Output: Display from Parent
        c.display();    // Output: Display from Child
        ref.display();  // Output: Display from Parent ğŸ‘ˆ (method hiding!)
    }
}
```

---

### ğŸ§© Output:

```
Display from Parent
Display from Child
Display from Parent
```

---

### ğŸ” Explanation:

1. Both `Parent` and `Child` define a **static method** `display()`.
2. But since **static methods are bound at compile time**, the call is resolved based on the **reference type**, not the object.
3. Hence:

    * `Parent ref = new Child();`
    * `ref.display()` calls **Parentâ€™s** `display()`, not Childâ€™s.

---

### âš–ï¸ Difference Between **Overriding** and **Hiding**

| Feature       | Overriding                | Hiding                        |
| ------------- | ------------------------- | ----------------------------- |
| Method type   | Instance method           | Static method                 |
| Bound at      | Runtime (Dynamic Binding) | Compile time (Static Binding) |
| Determined by | Object type               | Reference type                |
| Keyword       | `@Override` allowed       | `@Override` not allowed       |
| Polymorphism  | Supported                 | Not supported                 |

---

### ğŸ§  Quick Summary:

âœ… A subclass **can declare a static method with the same signature** as a superclass static method.
âŒ But this does **not override** it â€” it only **hides** it.
ğŸ“Œ Calls to static methods are resolved based on the **class reference type**, not the actual object type.

---

Would you like me to show how overriding vs hiding looks differently in memory/call flow (a small diagram)?


Perfect ğŸ‘ â€” these three points are about **method overriding rules** related to **visibility** and **return types** in Java. Letâ€™s break it down simply and clearly ğŸ‘‡

---

## ğŸ” What is **Visibility**?

Visibility (or **access level**) defines **where** a method or variable can be accessed from.

### Java Visibility Modifiers (from most to least accessible):

| Modifier               | Accessible From           | Visibility Level |
| ---------------------- | ------------------------- | ---------------- |
| `public`               | Everywhere                | Most visible âœ…   |
| `protected`            | Same package + subclasses | Moderate         |
| *default* (no keyword) | Same package only         | Limited          |
| `private`              | Within same class only    | Least visible âŒ  |

---

## ğŸ§© Rule 7:

### â“Can a public method in a parent class be overridden as protected or private?

**ğŸš« No â€” you canâ€™t reduce visibility.**

### Example:

```java
class Parent {
    public void show() {}
}

class Child extends Parent {
    // âŒ Not allowed: trying to make it less visible
    protected void show() {}  // Compilation error
}
```

âœ… Why? Because code that could access `show()` via the parent reference must still be able to access it in the subclass.

---

## ğŸ§© Rule 8:

### â“Can a protected method in a parent class be overridden as public?

**âœ… Yes â€” increasing visibility is allowed.**

### Example:

```java
class Parent {
    protected void display() {}
}

class Child extends Parent {
    @Override
    public void display() {} // âœ… Allowed, more visible
}
```

This makes the method accessible to a wider range of classes, which is fine in overriding.

---

## ğŸ§© Rule 10: Covariant Return Type

### â“What is it?

Covariant return type means:

> When overriding a method, the subclass can return a **subtype** of the superclassâ€™s return type.

### Example:

```java
class Animal {}
class Dog extends Animal {}

class Parent {
    Animal getAnimal() {
        return new Animal();
    }
}

class Child extends Parent {
    @Override
    Dog getAnimal() {  // âœ… Covariant return type
        return new Dog();
    }
}
```

Here, `Dog` is a subclass of `Animal`, so itâ€™s a **valid override**.

---

## ğŸ§  Summary Table

| Rule | Description                                  | Allowed? | Example                             |
| ---- | -------------------------------------------- | -------- | ----------------------------------- |
| 7    | Override public â†’ protected/private          | âŒ No     | Reducing visibility not allowed     |
| 8    | Override protected â†’ public                  | âœ… Yes    | Increasing visibility allowed       |
| 10   | Covariant return type (subclass return type) | âœ… Yes    | Return subtype instead of same type |

---

Would you like me to include a small visual chart showing how access modifiers â€œopen upâ€ or â€œclose downâ€ visibility between classes?



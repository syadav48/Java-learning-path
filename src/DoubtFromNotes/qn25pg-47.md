Qn: 25:
What are the rules for overriding a method in Java?
Rule #7: Use the super keyword to invoke the overridden method from a subclass.

Absolutely ✅ — let’s break down **Rule #7: “Use the `super` keyword to invoke the overridden method from a subclass”** with a clear example and explanation.

---

### 🧠 Concept Recap

When a **subclass overrides** a method from its **superclass**, sometimes you still want to call the **original version** (the superclass’s method) inside the subclass.
In such cases, you use the **`super`** keyword.

---

### 💡 Example: Overriding and Using `super`

```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
        
        // Calling the superclass version of sound()
        super.sound();
    }
}

public class SuperExample {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();
    }
}
```

---

### 🧩 Output:

```
Dog barks
Animal makes a sound
```

---

### 🔍 Explanation:

* `Dog` overrides the `sound()` method of `Animal`.
* Inside `Dog`’s `sound()` method, we still want to execute the original `Animal` version.
* So we use `super.sound()` to call the **overridden method** from the superclass.

---

### 🧱 Why use `super` in overridden methods?

1. To **extend** the parent method’s behavior instead of completely replacing it.
2. To **preserve base logic** (e.g., initialization, logging, etc.) defined in the parent class.
3. Useful in frameworks or when dealing with inheritance hierarchies.

---

### 🧠 Bonus Example — With Constructor

You can also use `super()` to call the **parent class constructor**:

```java
class Animal {
    Animal() {
        System.out.println("Animal constructor called");
    }
}

class Dog extends Animal {
    Dog() {
        super();  // invokes parent constructor
        System.out.println("Dog constructor called");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
    }
}
```

**Output:**

```
Animal constructor called
Dog constructor called
```

---

Would you like me to show a diagram (like memory and call flow between subclass and superclass when using `super`)?


 # Can a subclass provide its own implementation of a static method from the superclass?
Yes, but that is method hiding, not overriding.

Excellent question 👏 — this is a **common confusion point** in Java OOP:
👉 “Can a subclass provide its own implementation of a `static` method from the superclass?”

Let’s unpack this **carefully** — with an example and visual understanding.

---

### 🧠 Key Concept

* **Static methods** belong to the **class itself**, not to any specific object.
* Therefore, **they cannot be overridden**, because overriding works via **dynamic dispatch** (runtime polymorphism based on the object).
* However, a subclass **can define a static method with the same name and signature** — this is called **method hiding**, not overriding.

---

### 💡 Example — Method Hiding

```java
class Parent {
    static void display() {
        System.out.println("Display from Parent");
    }
}

class Child extends Parent {
    static void display() {   // method hiding (not overriding)
        System.out.println("Display from Child");
    }
}

public class StaticMethodExample {
    public static void main(String[] args) {
        Parent p = new Parent();
        Child c = new Child();
        Parent ref = new Child();  // Parent reference, Child object

        p.display();    // Output: Display from Parent
        c.display();    // Output: Display from Child
        ref.display();  // Output: Display from Parent 👈 (method hiding!)
    }
}
```

---

### 🧩 Output:

```
Display from Parent
Display from Child
Display from Parent
```

---

### 🔍 Explanation:

1. Both `Parent` and `Child` define a **static method** `display()`.
2. But since **static methods are bound at compile time**, the call is resolved based on the **reference type**, not the object.
3. Hence:

    * `Parent ref = new Child();`
    * `ref.display()` calls **Parent’s** `display()`, not Child’s.

---

### ⚖️ Difference Between **Overriding** and **Hiding**

| Feature       | Overriding                | Hiding                        |
| ------------- | ------------------------- | ----------------------------- |
| Method type   | Instance method           | Static method                 |
| Bound at      | Runtime (Dynamic Binding) | Compile time (Static Binding) |
| Determined by | Object type               | Reference type                |
| Keyword       | `@Override` allowed       | `@Override` not allowed       |
| Polymorphism  | Supported                 | Not supported                 |

---

### 🧠 Quick Summary:

✅ A subclass **can declare a static method with the same signature** as a superclass static method.
❌ But this does **not override** it — it only **hides** it.
📌 Calls to static methods are resolved based on the **class reference type**, not the actual object type.

---

Would you like me to show how overriding vs hiding looks differently in memory/call flow (a small diagram)?


Perfect 👏 — these three points are about **method overriding rules** related to **visibility** and **return types** in Java. Let’s break it down simply and clearly 👇

---

## 🔍 What is **Visibility**?

Visibility (or **access level**) defines **where** a method or variable can be accessed from.

### Java Visibility Modifiers (from most to least accessible):

| Modifier               | Accessible From           | Visibility Level |
| ---------------------- | ------------------------- | ---------------- |
| `public`               | Everywhere                | Most visible ✅   |
| `protected`            | Same package + subclasses | Moderate         |
| *default* (no keyword) | Same package only         | Limited          |
| `private`              | Within same class only    | Least visible ❌  |

---

## 🧩 Rule 7:

### ❓Can a public method in a parent class be overridden as protected or private?

**🚫 No — you can’t reduce visibility.**

### Example:

```java
class Parent {
    public void show() {}
}

class Child extends Parent {
    // ❌ Not allowed: trying to make it less visible
    protected void show() {}  // Compilation error
}
```

✅ Why? Because code that could access `show()` via the parent reference must still be able to access it in the subclass.

---

## 🧩 Rule 8:

### ❓Can a protected method in a parent class be overridden as public?

**✅ Yes — increasing visibility is allowed.**

### Example:

```java
class Parent {
    protected void display() {}
}

class Child extends Parent {
    @Override
    public void display() {} // ✅ Allowed, more visible
}
```

This makes the method accessible to a wider range of classes, which is fine in overriding.

---

## 🧩 Rule 10: Covariant Return Type

### ❓What is it?

Covariant return type means:

> When overriding a method, the subclass can return a **subtype** of the superclass’s return type.

### Example:

```java
class Animal {}
class Dog extends Animal {}

class Parent {
    Animal getAnimal() {
        return new Animal();
    }
}

class Child extends Parent {
    @Override
    Dog getAnimal() {  // ✅ Covariant return type
        return new Dog();
    }
}
```

Here, `Dog` is a subclass of `Animal`, so it’s a **valid override**.

---

## 🧠 Summary Table

| Rule | Description                                  | Allowed? | Example                             |
| ---- | -------------------------------------------- | -------- | ----------------------------------- |
| 7    | Override public → protected/private          | ❌ No     | Reducing visibility not allowed     |
| 8    | Override protected → public                  | ✅ Yes    | Increasing visibility allowed       |
| 10   | Covariant return type (subclass return type) | ✅ Yes    | Return subtype instead of same type |

---

Would you like me to include a small visual chart showing how access modifiers “open up” or “close down” visibility between classes?


